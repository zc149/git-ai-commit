# v0.4.0: 메시지 반복 및 캐시 기능

## 개요

v0.4.0에서는 사용자 경험을 개선하기 위해 커밋 메시지 반복 생성 기능과 캐시 시스템을 도입했습니다. 사용자가 AI 추천 메시지에 만족하지 않을 때 새로운 후보를 생성하고, 만족하는 메시지를 찾으면 이를 캐시하여 다음에 같은 작업을 할 때 재사용할 수 있습니다.

## 동기

### 문제 1: AI 추천이 마음에 안 들 때
- 기존에는 첫 번째 추천만 제공되었음
- 마음에 안 들면 `c`를 눌러 직접 입력해야 함
- 여러 번 시도하려면 명령어를 다시 실행해야 함

### 문제 2: 반복 작업의 비효율성
- 같은 타입의 커밋을 반복할 때마다 같은 메시지를 직접 입력하거나 여러 번 후보를 확인해야 함
- 예: 버그 수정 후 테스트 코드 수정 패턴이 반복될 때

## 해결 방안

### 1. 재추천 기능 (Regenerate)
- 후보 메시지를 확인하고 마음에 안 들면 `r` 키를 눌러 새로운 후보 생성
- 횟수 제한 없이 계속 새로운 후보를 생성할 수 있음

### 2. 캐시 시스템
- 선택한 메시지를 diff hash 기반으로 저장
- 같은 diff로 다시 시도할 때 캐시된 메시지를 `p` 키로 선택 가능
- 캐시 위치: `~/.git-ai-commit/cache.json`

### 3. 컨트롤 플로우 개선
- Go의 에러 인터페이스를 활용한 제어 흐름
- `RegenerateError`: 재추천 요청을 나타내는 에러
- `UsePrevMessageError`: 이전 메시지 사용 요청을 나타내는 에러

## 설계 결정사항

### Diff Hash 기반 캐싱

**결정**: 캐시 키로 diff hash 사용

**이유**:
- **안전성**: diff 내용이 같으면 동일한 커밋 메시지를 사용해도 안전
- **정확성**: 파일 이름만으로는 변경 내용의 일치를 보장할 수 없음
- **유연성**: 같은 파일이라도 변경 내용이 다르면 다른 캐시로 저장

**구현**:
```go
func CalculateDiffHash(diff string) string {
    hash := sha256.New()
    hash.Write([]byte(diff))
    return hex.EncodeToString(hash.Sum(nil))
}
```

### 에러 기반 제어 흐름

**결정**: 커스텀 에러 타입을 사용하여 제어 흐름 처리

**이유**:
- Go의 에러 인터페이스를 자연스럽게 활용
- 에러 타입 체크를 통한 명확한 제어 흐름
- 코드의 가독성과 유지보수성 향상

**구현**:
```go
// 재추천 에러
type RegenerateError struct{}
func (e *RegenerateError) Error() string {
    return "regenerate requested"
}

// 이전 메시지 사용 에러
type UsePrevMessageError struct {
    Message string
}
func (e *UsePrevMessageError) Error() string {
    return "use previous message"
}

// 사용 예시
if _, ok := err.(*RegenerateError); ok {
    // 새로운 후보 생성
}
if prevMsgErr, ok := err.(*ui.UsePrevMessageError); ok {
    selectedMessage = prevMsgErr.Message
}
```

### 캐시 저장소

**결정**: 파일 시스템에 JSON 형식으로 저장

**이유**:
- **단순성**: 별도의 데이터베이스나 의존성 불필요
- **이식성**: 홈 디렉토리를 사용하여 사용자별 캐시 관리
- **투명성**: JSON으로 쉽게 확인하고 수정 가능

**구현**:
```go
type CacheManager struct {
    cachePath string
}

type CacheData struct {
    DiffHash string    `json:"diffHash"`
    Message  string    `json:"message"`
    Timestamp time.Time `json:"timestamp"`
}
```

## 구현 세부사항

### 1. 캐시 매니저 (`internal/cache/cache.go`)

**주요 기능**:
- `NewCacheManager()`: 캐시 디렉토리 및 파일 생성
- `Load(diffHash)`: diff hash로 캐시된 메시지 로드
- `Save(diffHash, message)`: 선택한 메시지를 캐시에 저장

**캐시 구조**:
```json
{
  "entries": [
    {
      "diffHash": "abc123...",
      "message": "feat: add feature",
      "timestamp": "2024-02-09T17:00:00Z"
    }
  ]
}
```

### 2. UI 확장 (`internal/ui/selector.go`)

**새로운 옵션**:
- `r) Regenerate candidates`: 새로운 후보 생성 요청
- `p) Use previous message`: 캐시된 이전 메시지 사용 (이전 메시지가 있을 때만)

**메시지 포맷팅**:
```go
// 이전 메시지가 있을 때
p) 이전 메시지 사용 (feat: add feature)
1) feat: add feature
2) feat: implement feature
c) Custom input
r) Regenerate candidates
q) Quit

Select (p/1-2 or c/r/q): 
```

### 3. 메인 루프 수정 (`cmd/root.go`)

**재추천 루프**:
```go
for {
    selectedMessage, err = selector.Select(messages, prevMessage)
    
    if err != nil {
        // 재추천 요청
        if _, ok := err.(*ui.RegenerateError); ok {
            messages, err = generator.Generate(diffResult, detail, lang)
            continue
        }
        
        // 이전 메시지 사용
        if prevMsgErr, ok := err.(*ui.UsePrevMessageError); ok {
            selectedMessage = prevMsgErr.Message
            break
        }
        
        // 그 외 에러 (종료 등)
        return err
    }
    
    // 정상 선택
    break
}
```

**캐시 통합**:
```go
// 캐시 매니저 초기화
cacheManager, err := cache.NewCacheManager()
if err != nil {
    return fmt.Errorf("캐시 매니저 생성 실패: %w", err)
}

// 이전 메시지 로드
diffHash := git.CalculateDiffHash(diffResult.RawDiff)
cachedData, err := cacheManager.Load(diffHash)
var prevMessage string
if err == nil && cachedData != nil {
    prevMessage = cachedData.Message
}

// 선택한 메시지 캐시에 저장
if err := cacheManager.Save(diffHash, selectedMessage); err != nil {
    fmt.Println("⚠️ 커밋 메시지 캐시 저장 실패")
}
```

### 4. Diff Hash 계산 (`internal/git/diff.go`)

**함수 추가**:
```go
func CalculateDiffHash(diff string) string {
    hash := sha256.New()
    hash.Write([]byte(diff))
    return hex.EncodeToString(hash.Sum(nil))
}
```

## 사용 시나리오

### 시나리오 1: 후보가 마음에 안 들 때

1. `git-ai-commit` 실행
2. AI가 3개의 후보 메시지 생성
3. 후보들이 마음에 안 들음 → `r` 입력
4. 새로운 후보 3개 생성
5. 여전히 마음에 안 들음 → `r` 입력
6. 새로운 후보 3개 생성
7. 마음에 드는 후보 발견 → `1` 입력
8. 커밋 완료

### 시나리오 2: 반복 작업 효율화

1. 버그 수정 작업 수행 (패턴: 파일 변경 + 테스트 수정)
2. `git-ai-commit` 실행
3. 후보 확인 후 만족스러운 메시지 선택 → `2` 입력
4. 커밋 완료, 메시지 캐시에 저장
5. 다른 버그 수정 작업 수행 (같은 패턴)
6. `git-ai-commit` 실행
7. `p) 이전 메시지 사용 (fix: resolve bug)` 옵션 표시
8. `p` 입력하여 이전 메시지 재사용
9. 커밋 완료

## 장점

1. **사용자 경험 개선**: 마음에 안 드는 후보를 계속 재생성 가능
2. **시간 절약**: 반복적인 작업에서 이전 메시지를 재사용
3. **유연성**: 횟수 제한 없이 원하는 만큼 후보를 생성
4. **안전성**: diff hash 기반 캐싱으로 잘못된 메시지 재사용 방지
5. **단순성**: 파일 시스템 기반 캐시로 복잡한 의존성 없음

## 향후 개선 가능성

1. **캐시 만료**: 오래된 캐시 자동 삭제 기능
2. **캐시 관리**: 캐시 확인 및 삭제 명령어
3. **메시지 히스토리**: 선택했던 모든 메시지 히스토리 확인
4. **즐겨찾기**: 자주 사용하는 메시지 패턴 저장
5. **캐시 공유**: 팀 단위로 캐시 공유 (Git 기반)

## 테스트

### 수동 테스트 케이스

1. **재추천 기능**
   - 후보 확인 후 `r` 입력
   - 새로운 후보 생성 확인
   - 여러 번 반복 확인

2. **캐시 기능**
   - 메시지 선택 후 커밋
   - 같은 diff로 다시 시도
   - `p) 이전 메시지 사용` 옵션 확인
   - `p` 입력 후 캐시된 메시지 사용 확인

3. **캐시 무효화**
   - diff 변경 후 `git-ai-commit` 실행
   - `p` 옵션이 표시되지 않는지 확인

4. **옵션 조합**
   - 재추천 후 이전 메시지 사용
   - 직접 입력 후 캐시 확인

## 관련 파일

- `internal/cache/cache.go`: 캐시 매니저 구현
- `internal/ui/selector.go`: UI 옵션 및 에러 타입
- `cmd/root.go`: 캐시 통합 및 재추천 루프
- `internal/git/diff.go`: diff hash 계산

## 참고

- [Conventional Commits](https://www.conventionalcommits.org/)
- [Go Error Handling Best Practices](https://go.dev/doc/tutorial/errors)